Union Find
====

코테 끝나고 자세히 정리하자.    
**상호 배타적 집합(disjoint set)을 표현할 때 쓰는 자료구조.**    
구성 원소들이 서로 배타적인 부분 집합을 형성하는 것임.    
즉, 한 그룹에 같은 원소들이 있지 않도록, 한 원소는 한 부분 집합에만 속하도록 만들어 주는 자료구조입니다.    

유니온-파인드는 어떤 원소가 속한 집합을 찾아주는 **Find**기능과,     
주어진 두 원소가 서로 다른 집합에 속해 있을 때, 두 집합을 합쳐주는 **Union**기능을 가지고 있어,
**Union-Find**라고 불리우는 것 입니다.    

만드는 과정도 중요합니다.    
각 원소는 자기 자신만 원소로 있는 부분집합을 생성합니다. 그리고 문제의 조건에 따라 자신과 다른 집합과 집합을 합쳐 나갑니다.    
이런 방식을 이해하고 있어야 응용적인 풀이가 가능합니다.   
예를 들어 유니온-파인드를 이용해 최소 스패닝 트리를 만드는 법을 이해하거나, 집합이 합쳐지는 횟수를 알고 이를 활용하는 문제를 풀기 위해서는 이런 과정들을 이해하고 있어야 합니다.    .    

경로 압축을 적용하지 않고 잘 최적화가 된 경우 Union()과 find() 연산은 각각 O(logN)으로 구현됩니다.    
이정도만 되어도 매우 빠르지만, 경로압축이 어렵지 않기 때문에 굳이 안 할 필요가 없습니다.    
그래서 find()연산에 경로압축을 적용하면 O(a(n))의 시간 복잡도를 가지게 됩니다. a(n)은 애커만 함수로 정의되는 함수로 간단하게 모든 n에 대해 4이하의 결과 값을 가지는 함수입니다.    
**즉, 웬만한 입력에 대해 상수 시간에 동작합니다.**

**결론: Union()은 O(logN), find()는 상수 시간에 동작함.**

## 1. 트리로 구현한 Union-Find

- 볼 필요 없지만 경로 압축 X 버전

```C++
struct DisjointSet {
    vector<int> parent;
    DisjointSet(int N): parent(N) {
        for(int i = 0; i < N; i++) parent[i] = i;
    }
    
    // 원소 u의 최상위 조상을 반환합니다.
    int find(int u) {
        if(u == parent[u]) return u;
        return find(parent[u]);
    }
    void merge(int u, int v) {
        u = find(u); v = find(v);
        if(u == v) return;
        parent[u] = v;
    }
};
```
1. 처음 자신의 부모를 자신으로 둡니다. (혼자만 속한 그룹이 만들어지는 것.)
2. 문제의 조건에 따라 find를 통해 같은 그룹에 속해있는지 여부를 판단합니다.
3. 합쳐야 되는 경우 merge를 통해 두 그룹을 합칩니다.

### 경로 압축을 적용한 버전!
```C++
struct DisjointSet {
    vector<int> parent, rank;
    DisjointSet(int N): parent(N), rank(N, 1){
        for(int i = 0; i < N; i++) parent[i] = i;
    }

    // 원소 u의 최상위 조상을 반환합니다.
    int find(int u) {
        if(u == parent[u]) return u;
        return parent[u] = find(parent[u]);
        // 같은 그룹에 속한 원소들이 자신의 최상위 조상을 기억하게 해줌
    }
    void merge(int u, int v) {
        u = find(u); v = find(v);
        if(u == v) return;
        
        // 합칠 때 높이를 고려해서 더 깊이가 깊은 트리에 낮은 트리를 합쳐 주어
        // 깊이가 더 깊어지는 것을 막는다. 왼쪽에 더 낮은걸 둔다.
        if(rank[u] > rank[v]) swap(u, v);
        parent[u] = v;
        if(rank[u] == rank[v]) rank[v]++;
    }
};

```
1. **트리의 깊이를 표현하는 rank vector가 추가 되었다.**
2. 처음엔 원소가 1개이므로 rank가 1이다.
3. find()를 재귀적으로 호출하고 종료해가면서, 모든 그룹 내 원소들이 자기 그룹의 최상위 조상을 기억하도록 해준다.
4. merge() 연산 때는 랭크가 더 낮은 트리의 부모를 더 큰 트리의 부모로 삼아준다.
5. 두 트리의 랭크가 같은 경우 부모가 된 트리의 크기를 1 키워준다.    

경로 압축이 되지 않은 버젼을 쓸 이유가 딱히 없다. 웬만하면 이 쪽을 쓰자.


## 2. map으로 구현해본 버전
```c++
unordered_map<long long, long long> map;
int insert(int num) {
    auto itr = map.find(num);
    if(map[num] == 0) {
        map[num] = num + 1;
        return num;
    } else {
        map[num] = insert(itr->second);
        return map[num];
    }
}

```
    
재귀적으로 구현하였다. 문제는 [프로그래머스 호텔방 배정] 어디선가 많이 본 문제...    
문제는 예약하고 싶은 방의 번호가 이미 차 있다면 배치 가능한 방 중 가장 작은 숫자의 방에 배정하는 문제.       
내가 넣고 싶은 값이 없으면 그냥 넣고, 이미 있으면 value를 재귀적으로 조사한다. 여기서의 value는 배치된 끝 방이 되겠다.    
배치해주고, 재귀적으로 호출된 함수를 종료하면서 해당 union들의 value 값을 모두 마지막으로 배치해준 방 번호로 해주는 것이 포인트. (경로 압축)    
그럼 같은 유니온들은 모두 해당 유니온의 가장 끝 번호를 알게 되는 것이라 아주 짧은 시간 안에 모든 탐색이 가능해진다.    
이런 식으로 활용 하는 것은 처음인데 좋은 것 같다. 잊지 말자.




참고
====
알고리즘 문제해결전략 <구종만 저>

