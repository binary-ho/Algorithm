보석 쇼핑 - Two Pointer, Map
====

### 여러 종류의 보석들이 순서대로 나열되어 있을 때, 모든 종류의 보석을 포함한 가장 작은 범위를 구하는 문제! 
맵을 활용한 투 포인터 문제이다.

[문제 링크 (Programmers 카카오 인턴쉽 lv.3)](https://programmers.co.kr/learn/courses/30/lessons/67258)

투 포인터 문제를 분명 많이 풀었는데도 매번 한번에 못 풀어내는 것 같다. 비슷한 유형의 문제를 모아놓고 풀어보자.

풀이
---
Two Pointer와 Map을 사용한 근거 부터 짚고 넘어가겠다. __일정한 범위__ 내에 **모든 종류**의 보석이 1개 이상 존재하는지 물어보는 문제였기 때문에 일단 **어떤 범위를 계속 쓸고 지나가는 스위핑이 필요하여 투 포인터 방식을 생각하였고,** 단순한 갯수가 아닌 보석의 종류들을 모두 가지고 있는지 확인해야 했기 때문에 key값을 유일하게 갖는 map이나 set이 적합해 보였다. 갯수 또한 알고 있을 필요가 있기 때문에 string을 key로, 갯수를 int로 갖는 map이 적당해보였다. (이를 스위핑이 아니라 슬라이딩 윈도우라고 부르는 분을 봤는데, 슬라이딩 윈도우는 다른 개념입니다. 보통 스위핑은 정적인 범위를 하므로 투 포인터 문제라고 부르는 것이 적절해 보입니다.)

일단 문제에서 보석들이 몇 종류인지 주어지지 않았기 때문에, 종류를 세기 위해 Map을 이용하였다. 물론 set을 이용하는 편이 빠를 수도 있지만, 어차피 나중에 투 포인터 탐색 과정에서도 `Map<string, int> gems_map`를 활용할 것이기 때문에 map을 이용해주었다. map에 모든 원소를 넣은 다음 `gems_map.size()'를 이용하였다. 이를 통해 깔끔하게 종류의 수를 셀 수 있었다.

다른 방법으로는 vector를 sort한 이후, erase + unique를 이용해 모든 중복을 제거하고 size()를 이용해도 종류의 수를 셀 수 있다. 이번에는 컨테이너에 담긴 자료형이 무거운 string이라서 전부 복사하고, 정렬하고, 지우려니 무겁게 느껴져서, Map을 사용하였다.

보석의 종류를 구했으니 Map을 clear 해주고 탐색을 진행해주면 된다

```c++

int left = 0, right = 0, ans_range = 100001;
gems_map[gems[0]]++;  // 첫 보석 넣어주기

while(left < gems.size()) {
    // 답을 갱신해 주는 부분.
    if(gems_map.size() == gems_kinds) {
        if(ans_range > right - left) {
            ans_range = right - left;
            answer[0] = left + 1;
            answer[1] = right + 1;
        }
    }

    // 스위핑 진행
    if(right < gems.size() - 1 && gems_map.size() < gems_kinds) {
        right++;
        gems_map[gems[right]]++;
    } else {
        if(gems_map[gems[left]] == 1) {
            gems_map.erase(gems[left]);
        } else {
            gems_map[gems[left]]--;
        }
        left++;
    }
}
```
범위의 왼쪽과 오른쪽을 의미하는 변수 left, right를 선언합니다.
탐색 범위를 늘릴 때는 right를 ++하고, 줄일 때는 left를--합니다.
범위를 늘려가면서 map에 보석을 넣습니다. 그러다가 모든 종류를 가지게 되었음을 size()를 통해 알게 되면 기존의 최소 길이와 비교하여 답을 초기화합니다.
이후 범위를 한 칸씩 줄입니다.

이런 식으로 계속 탐색하면 약 $O(N)$의 복잡도로 ($2N$)탐색을 진행할 수 있습니다.
맨 처음에 0번 보석을 넣어줌에 유의합니다! 처음 범위가 0~0이기 때문에 꼭 해줘야 하는 행위입니다. 또한 시작 부터 넣어주고 탐색을 진행하였으므로, **값의 초기화 부분이 범위를 늘리고 줄이는 부분 보다 위에 존재해야합니다.**

이상으로 풀이를 마치겠습니다. 프로그래머스 lv3의 문제들은 체감상 백준 골드 하위권 문제의 난이도를 가진 것 같습니다. (Map, Set 자료구조를 활용한다는 점을 제외했을 때)
