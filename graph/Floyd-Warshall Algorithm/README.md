# Floyd-Warshall Algorithm 과 슬라이딩 윈도우
플로이드 와샬 알고리즘은 **그래프 내 모든 노드들의 쌍에 대해 최단거리를 알 수 있는 알고리즘이다.** <br>
플로이드-와샬 알고리즘은 `relaxtion`이라고 불리우는 **이완** 혹은 **완화** 작업을 통해. 계속해서 모든 노드쌍 간의 최단 거리를 알아낸다. <br> <br>

## 1. Relaxtion
어떤 노드쌍 i, j를 상상해보자. 어떤 한 노드 k를 거쳐서 i에서 j로 갔더니 i에서 j로 바로 갔을 때보다 더 작은 코스트로 이동할 수 있었다면, **최단거리는 당연히 노드 k를 거친 것을 채택해야 할 것이다.** <br>
어떤 점 kk를 생각해보자. i에서 kk로 갈 때, j를 거쳐 가면 더 빨랐었다고 생각해보자. <br>
그런데 이제, i에서 j로 갈 때 i-k-j 순서로 이동하면 더 짧은 것을 알게 되었으니, i-j-kk가 아니라, i-k-j-kk로 이동하는 것이 더 빠름을 알게 된다! <br>
이렇게 경유점들을 거친 거리를 계속해서 갱신시켜주면서, **원래 알고 있는 거리 보다 더 짧은 새로운 최단거리를 찾아내는 행위를 `완화` 라고 표현하는 것이다.** 알고 있는 최단 거리를 계속 깎아 주기 때문이다. <br> <br>

모든 노드 쌍에 대해 relaxtion이 끝난다면, 더 이상 완화 작업으로 인해 알고 있는 최단 거리가 깎이지 않는다. **그래프 내 총 노드의 갯수가 N개 일 때, 그것은 모든 노드에 대해 경유를 고려한 N회차 이후이다!** <br>
따라서 이런 완화 작업은 모든 노드쌍에 대해 총 N회 이루어집니다. 노드 쌍은 N^2개이므로, O(N^3)의 시간 복잡도를 갖는다.

## 2. 구현
주석에 자세한 설명을 적어 두었으니 읽으면서 이해하자.

```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

// 도달할 수 없는 아주 큰 값을 INF로 표현
int INF = 987654321;

// n은 총 노드의 갯수, m은 총 간선의 갯수
int n, m, src, dest, cost;
int edge[101][101]; // edge는 두 노드를 이어주는 간선의 cost
int dist[101][101][101];  // dist는 두 노드를 이어주는 최단거리. 맨 앞의 idx는 회차를 의미한다.

int main() {
    cin >> n >> m;
    /* 모든 경로에 대해 INF 값을 대입 */
    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) edge[i][j] = INF;

    /* 경로들을 입력으로 받는 부분
     * 이미 알고 있는 경로보다 더 짧은 경로라면 갱신해준다.
     * 초기에 모든 노드들간의 거리를 INF로 잡았으므로, 초기 입력은 무조건 받아들여진다. */
    for (int i = 0; i < m; i++) {
        cin >> src >> dest >> cost;
        if (edge[src][dest] > cost) edge[src][dest] = cost;
    }

    /*
     * 플로이드 - 와샬 전처리 과정: 1회차 1번 노드를 거치는 경로 갱신
     * i에서 j로 가는 경로를 결정하는데,
     * i에서 j로 가는 원래 경로와, **i에서 j까지 1번 노드를 거쳐서 가는 경로** 중에서,
     * 더 짧은 거리를 경로로 택한다.
     * 같은 노드간의 이동은 불가능 하므로, 0을 대입해준다.
     * */
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i != j) {
              dist[1][i][j] = min(edge[i][j], edge[i][1] + edge[1][j]);
              continue;
            }
            dist[1][i][j] = 0;
        }
    }

    /*
     * 모든 노드 쌍에 대해 거리를 계산한다
     * k는 몇 회차 이완 행위인지를 나타낸다. 전처리 과정 이후이므로 2 부터 진행한다.
     * k는 회차이자, 거져가는 지점을 의미한다.
     * 전 회차의 정보를 가지고 이번 회차의 정보를 갱신한다.
     * 기존에 알고 있던 경로와, 지난 회차에서의 k를 거쳐가는 경로 중에 더 작은 값으로 이완해준다.
     * 이렇게 n회 만큼의 반복, **즉 모든 노드 갯수 만큼** 의 완화 작업을 진행하면
     * 모든 노드 쌍에 대한 최단 경로가 성공적으로 완성된다.
     * */
    for (int k = 2; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                dist[k][i][j] = min(dist[k - 1][i][j], dist[k - 1][i][k] + dist[k - 1][k][j]);
            }
        }
    }

    /*
    * 모든 노드를 출력하는 코드
    * 아직도 값이 INF인 경우, 도달할 수 없는 노드를 의미한다. 
    * => 연결된 간선 없음!
    */
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int output = dist[n][i][j];
            if (output >= INF) output = 0;
            cout << output << ' ';
        }
        cout << '\n';
    }
}
```

## 3. 슬라이딩 윈도우 도입
현재 시간 복잡도와 공간 복잡도가 O(N^3)으로 상당히 높은 편에 속한다. 여기에 **슬라이딩 윈도우를 도입해서 공간 복잡도를 많이 줄여줄 수 있다.** <br> <br>

모든 쌍에 대해 최단 거리를 완화 주는 부분을 생각해보자. <br> 
이 완화 작업은 이전 회차의 완화 결과를 필요로 한다. <br>
**바로 이전 회차의 결과만을 요구하고, 2회차 이상 차이나는 회차의 결과를 요구하지는 않는다.** <br>
이 아이디어를 적용하면, **dist[101][101][101] 부분을 dist[101][101]으로 줄여줘도 된다!** <br>
이미 직전의 정보가 dist에 기록 되어 있고, 직전 정보만 참조하면 되므로, 101차원을 추가해줄 필요 없이, **그대로 그 위에 계속해서 써 주면 된다!**

```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int INF = 987654321;

int n, m, src, dest, cost;
int edge[101][101];

// dist를 두 차원으로 줄였다!
int dist[101][101];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) edge[i][j] = INF;

    // 시원하게 두 차원으로 줄였다.
    for (int i = 0; i < m; i++) {
        cin >> src >> dest >> cost;
        if (edge[src][dest] > cost) edge[src][dest] = cost;
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i != j) {
                dist[i][j] = min(edge[i][j], edge[i][1] + edge[1][j]);
                continue;
            }
            dist[i][j] = 0;
        }
    }

    /*
    * 연산 횟수까지 줄어드는 것은 아니나 공간 복잡도가 확 줄었다.
    * 어차피 모든 연산에 대해 이전 회차의 결과만이 필요했고,
    * 2회차 이상 차이나는 dist 결과는 필요 없었다.
    * 그래서 이렇게 줄일 수가 있는 것이다.
    */
    for (int k = 2; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int output = dist[i][j];
            if (output >= INF) output = 0;
            cout << output << ' ';
        }
        cout << '\n';
    }
}
```

### 참고

플로이드 와샬은 모든 쌍간의 최단거리를 구할 때 아주 유용하다. <Br> 
음수 간선에 대한 연산도 가능하지만, 다익스트라와 함께, 음수 사이클 감지는 불가능하다. 음수 사이클 감지는 벨만-포드를 확인하자.

## Reference
- 알고리즘 문제해결 전략 \<구종만 저>
