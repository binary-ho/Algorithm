# AVL 트리
(그림과 내용 보충 예정) <Br>
이진 탐색 트리를 만들 때 중요한 점은 무엇일까? 예를 들어 Heap을 떠올려 보자. ([Heap 이란?](https://github.com/binary-ho/Algorithm-and-Data-Structure/tree/main/Heap)) <br>

Heap은 아주 균형이 잘 잡힌 완전 이진 트리이다. 덕분에 아주 빠른 평균 탐색 시간을 가진다. <br>
무슨 말이냐면, 극단적으로 균형이 잡히지 않은, 한 쪽으로 노드가 전부 쏠린 이진 트리를 생각해보자. 루트로 부터 오른쪽 자식만 쭉~~ 있는 형태이다. <br>
과연 이 트리의 탐색 속도가 log2(N)일까? 절대 아니다, 오히려 **선형 시간을 가질 것이다.** <br>
이런 사실을 생각 해볼 때, **균형.** 트리의 균형은, **이진 트리의 탐색 수행에 지대한 영향을 미친다!** <br>


**동적으로 트리에 노드들이 계속해서 추가되는 상황에서..** 완전 이진 트리의 균형을 유지하기란 참 어렵다. **결국 재구성 과정이 필수적이다.**  <br>
AVL 트리는 서브트리들의 높이가 균형을 이루는 이진 트리 구조이다. N개의 노드에 대해 O(logN)의 검색, 삽입, 삭제 시간을 갖는다. <br>
AVL 트리가 어떻게 균형을 유지하는지 알아보자.

## 1. Height-balanced binary tree
아래 조건을 만족할 때, 트리 T는 높이 균형을 이룬다.
1. 왼쪽, 오른쪽 서브트리가 높이 균형을 이름
2. **왼쪽, 오른쪽 서브 트리의 높이의 차가 1이하이다.** 

이런 높이의 차이를 **balance fator - 균형 인수라고 부린다.** (BF) <br>
**균형 인수는** 어떤 한 노드를 기준으로 왼쪽, 오른쪽 서브트리의 높이 차이를 나타내는 수 이다.
- `BF(T) = hL - hR`이다.
- AVL 트리는 어떠한 노드 T에 대해서도 BF(T)가 -1, 0, 1을 유지해야한다!

## 2. 트리의 회전
AVL 트리에서는 균형을 지키기 위해, 균형이 깨진 경우 트리를 **회전** 시킨다. <br>
회전 시킨다니 무시무시한 생각인데.. 종류와 함께 방법을 알아보자. <br>
**삽입된 노드 Y와 가장 가까우면서 균형 인수가 +-2인 가장 가까운 조상 A에 대한 회전 성질!**
1. LL: Y가 A의 왼쪽 서브트리의, 왼쪽 서브트리에 삽입!
2. LR: Y가 A의 왼쪽 서브트리의, 오른쪽 서브트리에 삽입!
3. RR: Y가 A의 오른쪽 서브트리의, 오른쪽 서브트리에 삽입!
4. RL: Y가 A의 오른쪽 서브트리의, 왼쪽 서브트리에 삽입!

위와 같은 4가지 상황에 대해
1. **단일 회전(Single Rotation):** LL과 RR 불균형을 바로잡기 위한 변환. 체인이 회전하는 것과 같이 회전시킴
2. **이중 회전(Double Rotation):** LR과 RL 불균형을 바로잡기 위한 변환. 


## 3. 단일 회전
단일 회전은 심플하다. LL회전을 예시로 보자. BL에 노드 하나가 추가되면서, A의 균형 인수가 2가 됨으로서 균형이 깨졌습니다. A를 기준으로 L, L이기 때문에 LL 회전입니다. <br>
**LL에선 마치 체인을 오른쪽으로 감듯이 이동시켜줬다. 이후 그림과 같이 A의 균형 인수가 0이 되면서 성공적으로 균형이 맞춰졌다.**

## 4. 이중 회전
이중 회전은 **단일 회전을 두번 한 것이다.** <br>
예를 들어 왼쪽 서브 트리의 오른쪽 서브 트리에 노드가 삽입되는 경우, LR회전이 필요하다. 이는 단일 회전때 오른쪽 서브 트리의 오른쪽 트리에 노드가 삽입되는 경우 RR회전을 하듯, 
1. **왼쪽** 서브 트리의
2. **오른쪽** 서브 트리
**이므로 LR 회전이라고 생각하면 편하다.** <br>
이제 이름과 **거꾸로** 회전을 할 것이다. **조금의 팁인데, LR회전의 경우, RR 회전을 한 이후 LL 회전을 하면 된다!** <br>

그림을 아주 잘! 보자. LR회전은 분명 A 노드를 기준으로 필요한 행위지만, 아래의 순서를 따르라!
1. **B를 기준으로 RR 부터!!!** -> **B-C-C_R의 배치가 된다, (그림 추가 예정)**
2. **이후 A를 기준으로 LL 회전!!** -> **마지막과 같이 B - C - A 배치가 된다.**


<br>

AVL 트리는 이와 같은 회전 연산을 균형이 깨질 때까지 반복하여, 계속해서 균형 인수를 2보다 작게 만들어 준다! <br> 
그림을 보면 균형 인수가 2였던 루트 노드의 균형 인수가 어느새 0으로 잘 맞춰진 것을 볼 수 있다. 

## 5. 이중 회전을 쉽게 하는 방법
이중 회전을 그대로 받아들이면 머리가 아파진다. 원리적인 이해 말고, 조금 실용적인 설명을 해보겠다.
1. Balance Factor가 깨진 부분을 찾아낸다.
2. **거기서 부터 3개의 노드를 잡는다.**
3. **3개의 노드 중에서 중간 값을 갖는 value를 가진 노드를 루트로 삼아 트리를 재구성한다.**
4. 아마도 가장 아래에 있던 노드가 가운데 루트로 올 것이다.
5. 이후, 각 노드를 원래 붙어있던 위치에 붙여준다.
6. 그럼 새로 루트가 된 노드에 원래 붙어 있던 자식 노드가 남게 된다.
7. 방향에 맞게 서브 트리를 고른 다음 남는 자리에 넣어주면 된다.

![avl2](https://user-images.githubusercontent.com/71186266/205694370-47bfcc0f-1cf3-461f-ab20-9594f418abc3.png)
  
위의 트리에 숫자 8을 대입하겠다고 생각해보자.

![avl3](https://user-images.githubusercontent.com/71186266/205694375-40941ada-5e57-42a7-a82b-f2ac5ef398ad.png)
1. 8의 위치를 위와 같이 찾는다.
2. Balance Factor를 체크한다.
3. 7이 -2, 12가 1, 11이 1로 밸런스가 무너짐을 확인!

<br>

![avl4](https://user-images.githubusercontent.com/71186266/205694379-8bc12c35-26c9-4e21-9473-40914f86f409.jpg)

4. 위에서 언급한 대로 노드 3개를 잡는다. 7, 12, 11
5. 그리고 7, 12, 11의 중간값인 11이 루트가 되도록 트리를 재구성한다!!
6. 그리고 7의 좌에 있던 노드 4는 7의 좌, 12의 우에 있던 노드 13은 12에 우에 둔다.
7. 남은 8은 맞는 위치에 둔다. 원래 11의 좌였으니까, 11의 좌측 서브 트리로 빠졌고, 거기서 맞는 위치를 찾아갔다.


이런 방식으로 이중 회전 또한 직관적으로 이해할 수 있다. <br>
이게 전부가 아니다. 구체적인 트리 구성 순서와 코드를 알 필요가 있다. 조만간 추가하겠다.

## Reference
- Fundamentals of Data Structures in C++ \<HOROWITZ, SAHNI, MEHTA 저>
