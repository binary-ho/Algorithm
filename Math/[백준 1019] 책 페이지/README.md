[백준 1019] 책 페이지
====

책 페이지는 1 페이지 부터 N 페이지까지 0~9의 숫자가 각각 몇 개가 나오는지 세는 문제이다.    
N은 최대 10억이므로 단순 계산으로는 매우 오랜 시간이 걸리게 된다. 어떤 수 k에 대해서 자릿수 만큼 연산 시간이 걸리므로, 시그마 1 ~ 10억까지 log(k)만큼의 시간이 걸리게 되겠다.
<br/>

보통의 수학 문제가 그렇듯 일정한 규칙을 찾아 보았다. 0을 제외한 숫자들은 매우 간단하다. 10의 0제곱 자리에서는 1~9까지 모든 숫자에 1이 더해진다. 10의 1제곱 자리 10~99까지는 
1~9가 10번 반복되고, 10의 자리 숫자가 1~9까지 한번씩 나오기 때문에 각각 10회가 추가 되어, 1*10 + 10 만큼의 숫자가 1~9에 더해진다. <br/>

어떤 수 k에 대해서 10의 k제곱의 1~9 갯수를 dp[k]라고 하면, dp[k] = dp[k-1]*10 + 10^k 이다. 이와 같은 점화식을 통해 간단하게 10의 자릿수 숫자마다 더해지는 1~9의 갯수를 알게 된다.
<br/>

이를 나타낸 것이 dp배열이고, 자릿수가 k일 때 1~9에 dp[k-1]만큼을 더해준 다음. --- (A)    
k번째 자릿수의 숫자에 10^(k-1)을 더해주면 된다. --- (B)    
이후, k-1번째 자릿수까지의 숫자 만큼의 
횟수를 k번째 자릿수의 숫자에 또 더해줘야 하는데, 이는 처음에 dp를 만들어 줄 떄 1~9일떄는 10을, 10~99일때는 100을 빼는 식으로 구현했기 때문에, k번째 자릿수의 숫자가
몇 번 나왔는지는 아직 최종적으로 세지 않았기 때문이다. 이를테면, 1004라는 숫자가 있으면 (A), (B)까지의 계산은 999까지의 1이 등장한 횟수일 뿐이고, 1000~10004까지 1이 등장한 횟수가
반영이 안 되어있기 때문이다. 

<br/> 

이후 k번째 자릿수에 k-1번째 자릿수까지의 숫자의 합 sum_num을 더해주면 1~9까지는 전부 세게 되는 것이다.

**이제 까다로운 0의 계산이 남았다.** 0은 일단 다른 숫자들과 똑같은 규칙으로 계속 세어준다. 그리고 2가지 예외 연산을 진행해준다.    
1. 맨 앞의 자릿수가 0인 경우는 사실상 k-1번째 자릿수의 계산에서 이미 세준 것과 같다. 그래서 맨 앞 자릿수에서는 (B)연산을 진행하지 않는다.    
2. 맨 마지막에 0보정값을 빼 준다.     
0 보정값은 내가 임의로 만든 보정값인데, k-1 자릿수까지 10^k를 모두 더한 값이다. (A)연산의 과정에서 자연스럽게 0을 더 10^k-1씩 더 더하게 되는데, 이를 빼준 값이다.    
 
```C++
#include<iostream>
#include<algorithm>

using namespace std;

int ten_power[] = {1, 10, 100, 1000,10000,100000,1000000,10000000,100000000};
int zero_bias[] = {1, 11, 111, 1111,11111,111111,1111111,11111111,111111111};
int ans[10];  // 답을 담는 배열
int dp[9]; 

void sum(int lim, int num) {
    for(int i = 0; i <= lim; i++) ans[i]+=num;
}

void sum(int start, int end, int num) {
    for(int i = start; i <= end; i++) ans[i]+=num;
}

int main() {
    dp[0] = 1;
    for(int i = 1; i <= 8; i++) {
        dp[i] = dp[i-1]*10 + ten_power[i];
    }
    int N;
    cin >> N;
    string str = to_string(N);
    int length = str.size();
    length--;

    int num_now;
    int sum_num = str[length] - '0';
    sum(0, sum_num, 1);
    if(length == 0) ans[0] -= 1;
    for(int i = 1; i <= length; i++) {
        num_now = str[length - i] - '0';
        for(int j = 0; j < num_now; j++) {
            sum(9, dp[i-1]);  // (A)
             if(i != length || j != 0) ans[j] += ten_power[i]; // (B)
        }
        if(i == length) ans[0] -= zero_bias[i-1];
        ans[num_now] += sum_num + 1;
        sum_num += num_now * ten_power[i];
    }
    for(int i = 0; i < 10; i++) {
        cout << ans[i] << " ";
    }


    return 0;
}
```
